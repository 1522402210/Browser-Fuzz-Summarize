

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>5. Fuzz相关论文 &mdash; browser_fuzz_summarize 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="6. Fuzz实现" href="tool.html" />
    <link rel="prev" title="4. Fuzz方法" href="fuzz.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> browser_fuzz_summarize
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. 浏览器内核简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="mitigation.html">2. 浏览器防护措施</a></li>
<li class="toctree-l1"><a class="reference internal" href="vultype.html">3. 浏览器漏洞类型</a></li>
<li class="toctree-l1"><a class="reference internal" href="fuzz.html">4. Fuzz方法</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">5. Fuzz相关论文</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#scheduled-dom-fuzzing">5.1. Scheduled DOM Fuzzing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gramfuzz-fuzzing">5.2. GramFuzz Fuzzing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">5.2.1. 主流程伪代码</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extract-the-grammar-node">5.2.2. Extract the Grammar Node</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dom-level-fuzz">5.3. DOM Level Fuzz</a></li>
<li class="toctree-l2"><a class="reference internal" href="#one-fuzzing-template-revealed-over-100-ie-uaf">5.4. one fuzzing template revealed over 100 IE UAF</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fileja">5.5. Fileja</a></li>
<li class="toctree-l2"><a class="reference internal" href="#predicting-vulnerable-software-components">5.6. predicting vulnerable software components</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mongodb-s-javascript-fuzzer">5.7. MongoDB’s JavaScript Fuzzer</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tool.html">6. Fuzz实现</a></li>
<li class="toctree-l1"><a class="reference internal" href="grinder.html">7. Grinder</a></li>
<li class="toctree-l1"><a class="reference internal" href="ref.html">8. 参考资料</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">browser_fuzz_summarize</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>5. Fuzz相关论文</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/fuzz-paper.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="fuzz">
<h1>5. Fuzz相关论文<a class="headerlink" href="#fuzz" title="Permalink to this headline">¶</a></h1>
<div class="section" id="scheduled-dom-fuzzing">
<h2>5.1. Scheduled DOM Fuzzing<a class="headerlink" href="#scheduled-dom-fuzzing" title="Permalink to this headline">¶</a></h2>
<p>该方法[1-1]是基于一些有联系的浏览器fuzz工具和一个名为BFF的fuzz框架结合后优化得来。这种方法对fuzz做出的主要优化是并不以同等的概率选择种子以及种子变换的概率，而是在fuzz的过程中，计算更容易产生crash的种子以及变换方式，从而动态的变化选择种子/变换方式的概率，以期以更高的概率获得crash。该篇文章的实验部分对比了zzuf、crossfuzz等fuzz方式，获得了倍于这些工具的crash，以此认为该方法是有效的。</p>
</div>
<div class="section" id="gramfuzz-fuzzing">
<h2>5.2. GramFuzz Fuzzing<a class="headerlink" href="#gramfuzz-fuzzing" title="Permalink to this headline">¶</a></h2>
<p>该方法[1-7]的改进点主要有两个。一个在于不直接生成种子，而是从网上获取已经有的html文档，并对其进行分析后获得一个比较庞大的语法库，然后使用语法库获得种子。变换方法则更基于语法规则进行变化，而不是随机生成一些值。</p>
<p>尝试把其主要流程写成了如下的伪代码：</p>
<div class="section" id="id1">
<h3>5.2.1. 主流程伪代码<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">webFiles</span> <span class="o">=</span> <span class="n">Crawler</span><span class="o">.</span><span class="n">getHTMLfromInternet</span><span class="p">()</span>
<span class="n">trainSets</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TrainSets</span><span class="p">(</span><span class="n">webFiles</span><span class="p">)</span>
<span class="n">initCases</span> <span class="o">=</span> <span class="n">new</span> <span class="n">InitialCases</span><span class="p">(</span><span class="n">webFiles</span><span class="p">,</span> <span class="n">Pocs</span><span class="p">)</span>
<span class="n">grammarLibrary</span> <span class="o">=</span> <span class="p">{</span><span class="n">JsLib</span><span class="p">,</span> <span class="n">HTMLLib</span><span class="p">,</span> <span class="n">CSSLib</span><span class="p">}</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GrammarLibrary</span><span class="p">(</span><span class="n">trainSets</span><span class="p">)</span>
<span class="n">grammarNode</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GrammarNode</span><span class="p">(</span><span class="n">grammarLibrary</span><span class="p">)</span>
<span class="n">testCases</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Testcases</span><span class="p">(</span><span class="n">grammarNode</span><span class="p">,</span> <span class="n">mutatePattern</span><span class="p">(</span><span class="n">initCases</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="extract-the-grammar-node">
<h3>5.2.2. Extract the Grammar Node<a class="headerlink" href="#extract-the-grammar-node" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">currentNode</span> <span class="o">=</span> <span class="n">rootNode</span>
<span class="n">grammarNodeDB</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">searchLeafNode</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Node</span><span class="p">()</span>
    <span class="n">tmp</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">code</span>
    <span class="n">tmp</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">type</span>
    <span class="n">grammarNodeDB</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">searchChildNode</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">searchLeafNode</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">nextLeafNode</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">tmp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">searchLeafNode</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">nextLeafNode</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">rootNode</span><span class="p">):</span>
    <span class="n">searchChildNode</span><span class="p">(</span><span class="n">rootNode</span><span class="p">)</span>
</pre></div>
</div>
<p>该文章的主要优点在于测试者不需要对DOM树，CSS，或者Js语法有了解，只要使用代码库就可以了。另外，从真实HTML文件中的代码会对接口有更高的覆盖率，而且生成测试样例使用了语法树的方法，给测试例子触发漏洞以更多的可能性。</p>
</div>
</div>
<div class="section" id="dom-level-fuzz">
<h2>5.3. DOM Level Fuzz<a class="headerlink" href="#dom-level-fuzz" title="Permalink to this headline">¶</a></h2>
<p>这是Nduja[3-5]实现的主要的思路。该方法认为基于DOM的Fuzz可以分为三个层次，第一层是常规的随机生成元素，这种思路是最普遍的，所以效率不高。作者认为应该从更高的层次去fuzz。比如基于DOM的第二（基于逻辑）第三层（基于事件）进行fuzz，以期获得更好的效果。</p>
<p>从第二层出发，更多考虑的是基于DOM逻辑进行变换。举例来说，在一棵DOM树上，存在的逻辑有firstChild/lastChild/nextNode/previousNode/nextSiebling/previousSiebling等，而节点则存在detach/attach/nextNode/previousNode等逻辑，可以基于这相关的逻辑进行变换。</p>
<p>第三层考虑的是DOM之间发生变化时相应触发的事件。利用事件之间的逻辑关系去fuzz，比如节点A发生detach时，会触发让该节点attach到节点B的动作，但是又会触发节点删除子节点的动作。用这样一些逻辑上的边界条件去尝试fuzz。</p>
</div>
<div class="section" id="one-fuzzing-template-revealed-over-100-ie-uaf">
<h2>5.4. one fuzzing template revealed over 100 IE UAF<a class="headerlink" href="#one-fuzzing-template-revealed-over-100-ie-uaf" title="Permalink to this headline">¶</a></h2>
<p>这篇文章出自black hat Europe 2014的一篇讲稿，感觉比较有启发性</p>
<p>作者提出</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>– Engineers are not good at repairing
– Engineers make mistakes taking things apart (undoing)
– Engineers made mistakes putting things back together (redoing)
</pre></div>
</div>
<p>从这里就延伸出去想到工程师可能会犯错的地方，然后fuzzer就从下面这些地方的思路开始构造</p>
<ul>
<li><dl class="first docutils">
<dt>Explicit Pairings</dt>
<dd><p class="first">– Direct: ‘on/off’, ‘true/false’, properties.
- e.g.</p>
<blockquote class="last">
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">display=&quot;block&quot;/&quot;none&quot;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">appendChild/removeChild</span></code></li>
<li>addEventListener : <code class="docutils literal notranslate"><span class="pre">focusin/focusout</span></code></li>
</ul>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Implicit Pairings</dt>
<dd><ul class="first last">
<li><p class="first">Indirect: inheritance, nullity, state change.</p>
</li>
<li><p class="first">e.g.</p>
<blockquote>
<div><ul class="simple">
<li>Content: <code class="docutils literal notranslate"><span class="pre">innerText=''/</span> <span class="pre">document.write('')</span></code></li>
<li>Relation: swap parent/child node</li>
<li>Status: <code class="docutils literal notranslate"><span class="pre">window.navigate('')</span> <span class="pre">/</span> <span class="pre">location.reload()</span></code></li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Hybrid Pairings</dt>
<dd><ul class="first last">
<li><p class="first">Complexity of mixing explicit and implicit.</p>
</li>
<li><p class="first">Script (Dynamic) + HTML (Static)</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&lt;body</span> <span class="pre">contentEditable='true'&gt;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">Document.body.contentEditable='false';</span></code></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Property + Method</p>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Pairing Combinations</dt>
<dd><p class="first last">– Multiple pairings per page.</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="fileja">
<h2>5.5. Fileja<a class="headerlink" href="#fileja" title="Permalink to this headline">¶</a></h2>
<p>fileja在nduja的基础上有两个比较大的改进的地方
一个是增加了一些对时间敏感的操作，这个是针对
所有浏览器的</p>
<p>另外，对于IE支持的多脚本引擎的特性，也特别做了fuzz</p>
<p>这里提到的时间敏感的操作主要是说之前的文章对DOM的操作都是同步的
而在这篇文章中引入了xhr和WebSocket</p>
<p>主要有这三种fuzz的行为：</p>
<ul class="simple">
<li>同步/异步server返回</li>
<li>通过setTimeout 或 setInterval API同时运行多个call</li>
<li>任意时间延迟</li>
</ul>
<p>这样则将导致</p>
<ul class="simple">
<li>在一个API调用的中间会触发一次DOM的变化</li>
<li>ws/xhr的配置还没有改动但是主页面已经跳转了</li>
<li>race condition</li>
</ul>
</div>
<div class="section" id="predicting-vulnerable-software-components">
<h2>5.6. predicting vulnerable software components<a class="headerlink" href="#predicting-vulnerable-software-components" title="Permalink to this headline">¶</a></h2>
<p>这篇文章的主要贡献在于给出了一个预测在大型软件中，某个模块漏洞出现概率的方法。可以通过该方法预测更容易出现漏洞的模块，从而有针对性的进行审计。
该文章使用的主要方法为从https://bugzilla.mozilla.org中获取了firefox历年来的漏洞，使用机器学习的方法对其进行聚类。</p>
<p>个人觉得这个思路是可以借鉴的，如果白盒符号执行的时候路径过多，可以使用该方式进行启发式的路径选择，从而更高效的测试。</p>
</div>
<div class="section" id="mongodb-s-javascript-fuzzer">
<h2>5.7. MongoDB’s JavaScript Fuzzer<a class="headerlink" href="#mongodb-s-javascript-fuzzer" title="Permalink to this headline">¶</a></h2>
<p>这篇文章是由MongoDB开发者为这个项目写的fuzzer的一个总结。</p>
<p>许多fuzzer都依赖明确的语法来生成测试，这种语法使得这些测试变得更加智能。但是在这个fuzzer中，作者并没有直接构建语法库，而是从JavaScript集成测试语料库中借鉴了MongoDB命令语法的知识，随机地突变它们以创建新的测试用例。</p>
<p>当fuzzer运行时，它使用JS测试的随机子集作为种子。Fuzzer将它们转换为JavaScript解释器可以理解的形式的AST。 然后，通过有选择地替换节点，对其进行随机化并替换它们的值，在树上造成受控制的破坏。这样就可以测试正常测试中不会遇到的参数生成命令，但是保留了有效的JavaScript对象的整体结构。</p>
<p>这个fuzzer在变异的时候的优点有</p>
<ul class="simple">
<li>使用基于AST替换而不是正则</li>
<li><dl class="first docutils">
<dt>使用启发式的替换而不是完全随机</dt>
<dd><ul class="first last">
<li>在要替换时，更多的替换容易产生的问题的值或者类型</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>但是这样的fuzzer会有一个盲点，因为语料库全部来自于人工的测试样例，所以难免有所遗漏，所以作者也加入了一些随机的字符串样本来盲测作为这个缺点的弥补</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="tool.html" class="btn btn-neutral float-right" title="6. Fuzz实现" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="fuzz.html" class="btn btn-neutral" title="4. Fuzz方法" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, lyle.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>